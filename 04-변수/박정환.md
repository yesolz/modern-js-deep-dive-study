# 04. 변수

## 하나의 값을 저장하기 위해 확보한 메모리 공간 식별을 위해 붙인 이름

자바 스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다. [치명적 오류가 나타날수 있음]

```jsx
var result = 10 + 20;
```

- **할당**: 변수의 값을 저장,대입 하는 것
- **참조**: 변수의 저장된 값을 읽어 들이는 것

<br>
<aside>
💡 **키워드**: JS 가 수행할 동작을 규정한 일종의 명령어
예} var 키워드는 변수를 선언한다는 뜻
   
</aside>
</br>

<br>
<aside>
💡 **var 키워드는 여러 단점이 있다.** 
블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원하여 전역 변수가 선언되어
심각한 부작용이 발생하기도 한다.  
  
</aside>
</br>

<br>
<aside>
💡 **가비지 콜렉터**: 사용되지 않는 메모리를 해제하는 기능
JS 는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수 방지
   
</aside>
</br>

<br>
<aside>
💡 **매니지드 언어:** 메모리 할당,해제를 위한 관리 기능을 언어 차원에서 당담
[개발자가 명시적으로 메모리 할당,해제 x]
**언매니지드 언어:** 개발자가 명시적으로 메모리를 할당하고 해제를 해아 하는 언어
  
</aside>
</br>

## 4.2 식별자

### 변수 이름을 식별자 라고 부르기도 한다.

식별자는 메모리 주소에 붙인 이름이라고 할수 있다.

**result**[식별자] > **0x066F913** [메모리 주소] **30** [메모리]

## 4.3 변수 선언

### 변수를 생성하는 것을 말한다.

- **변수 선언** (var, let, const)

```jsx
var score; // 변수 선언
```

1. **선언 단계** : 변수 이름을 등록해 JS엔진에 변수의 존재를 알림
2. **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보 후 undefined를 할당해 초기화

초기화를 진행하지 않으면 메모리 공간에는 이전 애플리케이션이 사용했던 값이 남아 있을수 있다. [쓰레기 값 (garbage value)]

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```jsx
console.log(score); // undifined

var score; //변수 선언문
```

선언문 보다 참조하는 코드가 앞에 있다.  인터프리터에 의해 순차적으로 실행이 된다.

하지만 참조 에러가 나타나지 않는 이유는 JS 엔진은 변수 선언 코드가 어디있든 다른 코드보다 먼저 실행된다. [런타임 이전 실행]

이런 JS 고유의 특징을 **변수 호이스팅** 이라고 한다.

**[모든 식별자는 호이스팅 된다.]**

## 4.5 값의 할당

### 할당 연산자 (=) 를 사용 하여 우변의 값을 좌변의 변수에 할당한다.

```jsx
console.log(score); // undifined (2)

var score; //변수 선언 (1)
score = 80; //값의 할당 (3)

console.log(score); // 80 (4)
```

값의 할당은 **런타임**에 실행된다.

```jsx
var score = 80; // 변수 선언과 값의 할당
```

이 경우 2개의 문으로 나누어 각각 실행한다.

var score[변수 선언] > undefined [메모리]

score = 80 > (undefined) - 80 [메모리]

## 4.6 값의 재할당

### 이미 할당되어 있는 변수에 새로운 값을 할당 하는 것이다.

```jsx
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

변수 선언을 할때 메모리에 undefined가 있기에 값의 할당을 진행할때 재할당이 맞다.

값의 재할당의 경우 이전 값을 버리지 않고 가지고 간다.

var score[변수 선언] > undefined [메모리]

score = 80 > (undefined) - 80 [메모리]

score = 90 > (undefined) - (80) - 90 [메모리]

undefined, 80 이라는 값은 어떠한 식별자와도 연결되어 있지 않아 필요하지 않고 가비지 콜렉터에 의해 메모리에서 자동 해제 된다. [언제 해제될지는 예측불가]

## 4.7 식별자 네이밍 규칙

### 특수문자를 제외한 문자,숫자,(_),($) 포함 가능하다.

**[숫자로 시작 불가능, 예약어 사용 불가능]**

- **네이밍 컨벤션**

```jsx
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName;

// 헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + indentifier
```

카멜 케이스와 파스칼 케이스가 유용하게 쓰인다.
