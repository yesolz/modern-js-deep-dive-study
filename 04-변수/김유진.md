# 4. 변수

4.1 변수란 무엇인가? 왜 필요한가?<br>
4.2 식별자<br>
4.3 변수 선언<br>
4.4 변수 선언의 실행 시점과 변수 호이스팅<br>
4.5 값의 할당<br>
4.6 값의 재할당<br>
4.7 식별자 네이밍 규칙

## 변수란 무엇인가? 왜 필요한가?

#### 자바스크립트 코드를 실행하면 `컴퓨터`에서 일어나는 일 : <br>

💡10 + 20식 계산<br>

- 기호(10, 20 +)와 식(10 + 20)의 의미를 모두 해석할 수 있어야 함!<br>
  `+` 연산 수행을 위해 좌/우의 숫자 값인 '피연산자'를 기억<br>

`연산자`: 기호(+, =)<br>
`피연산자` : 연산을 당하는 인수(10, 20)

- **컴퓨터**는 연산은 `CPU`를, 기억은 `메모리`를 사용한다.

`메모리` : 데이터를 저장할 수 있는 메모리 셀의 집합체 <br>
`메모리 셀` : 컴퓨터가 데이터를 저장하는 단위, 크기는 1바이트(8비트)

#### 컴퓨터는 모든 데이터를 `2진수`로 처리한다.<br>

컴퓨터가 하드웨어의 **물리적 특성**과 **디지털 논리의 특성**(and, or, not)때문에 전안의 유무에 따른 전기적 신호(켜짐(1) 꺼짐(0))를 사용하여 데이터를 처리하기 때문이다. <br>
따라서 피연산자는 `메모리`에 기억되고 `CPU`는 메모리 값을 읽어들여 연산을 수행하며, 연산 값도 `메모리`에 저장된다.

#### ❗여기서 문제는 CPU가 연산해서 만들어낸 숫자값인 30을 재사용할 수 없다는 것

연산 결과인 30을 재사용하기 위해 메모리주소를 통해 저장된 메모리 공간에 접근하는 것이 유일한 방법인데, 치명적인 오류를 발생시킬 가능성이 높기에 **자바스크립트는 개발자의 `직접적인 메모리 제어`를 허용하지 않는다.**

따라서 기억하고 싶은 값은 메모리에 저장하고 재사용하기 위해 `변수` 라는 매커니즘을 제공한다.

### 변수

: 변수는 하나의 값을 저장하기 위해 메모리에서 확보한 공간<br>
➡️ 컴파일러 또는 인터프리터에 의해 값이 저장된다.

#### 💡변수에 여러 개의 값을 저장하는 방법

: 변수는 하나의 값을 저장하기 위한 매커니즘이기에, 여러 개의 값 저장하려먼 배열이나 객체 자료구조를 사용해 그룹화하여 사용할 수 있다.


변수 이름을 사용해 `참조`를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근한 후 저장된 값을 반환한다.<br>

`할당` : 변수에 값을 저장하는 것 <br>
`참조` : 변수 값을 읽어 들이는 것 <br>

➡️ 따라서 가독성 높은 이름을 짓는 것이 중요!!

## 식별자

#변수 이름=식별자

: 메모리 공간을 식별하기 위해서 붙인 변수의 고유한 이름

- 식별자는 메모리 주소를 기억한다 = 메모리 주소 이름<br>
- 식별자는 값이 저장된 메모리 주소와 `매핑 관계`를 맺음(이 `매핑 정보`도 메모리에 저장).

- 변수 이름에만 국한하지 않고, **변수, 함수 , 클래스 등**이 모두 식별자

## 변수 선언

: 변수 생성을 의미하며, 정확히는 값을 저장하기 위한 메모리 공간을 확보하고 주소를 연결해서 값을 저장할 준비를 하는 것으로, **변수를 사용하려면 반드시 선언이 필요하다.** 만일 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다.

#### 키워드

자바스크립트 코드를 해석하고 실행하는 JS엔진이 수행할 동작을 규정한 일종의 명령어

#### 변수 선언 키워드

- var: `선언 단계` + `초기화 단계` 동시 진행
- let
- const

#### 자바스크립트 엔진의 변수 선언 2단계

- `선언 단계` : 변수 이름 등록
- `초기화 단계` : 값 저장을 위한 메모리 공간 확보 + 암묵적으로 `undefined`를 할당해서 초기화

#### ES5 vs ES6<br>

ES6는 ES5의 상위 집합

- ES5에서 구현되 코드는 ES6 기반 자바스크립트 엔진에서 모두 정상적으로 동작
- **ES6에서 let과 const가 도입** ➡️ ES5에는 var 키워드를 사용해 구현되어있을 것임

ES6에서 let과 const를 도입한 이유는 var의 단점 보완을 위해서였다.<br> var는 `블록 레벨 스코프`를 지원하지 않고 `함수 레벨 스코프`를 지원해서 의도치 않은 전역 변수가 선언되어 부작용이 발생하기도 한다는 단점이 있다.

#### undefined

변수를 선언한 후 값이 할당되지 않으면 메모리 공간이 비어있을 것 같지만, 확보된 메모리 공간에는 JS 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 **초기화**된다. ➡️ 자바스크립트의 독특한 특징

`초기화` : 변수 선언 이후 최초로 값을 할당하는 것.<br>
초기화 단계를 거치지 않으면 다른 애플리케이션 값이 사용했던 갓이 남아 있을 수 있다. 이 값을 **쓰레기 값**이라고 한다.

#### 변수 이름 등록 where?

변수 이름을 비롯한 모든 식별자는 `실행 컨텍스트`에 등록된다.<br>
`실행 컨텍스트` : JS 엔진이 소스코드를 평가하고 실행하기 위한 환경을 제공하고 결과를 관리하는 영역으로, 식별자와 스코프를 관리한다.

## 변수 선언의 실행 시점과 변수 호이스팅
자바스크립트는 인터프리터 언어로, 한 줄씩 순차적으로 실행되기에 참조 에러가 발생한 것처럼 보이기도 한다. 하지만, 참조 에러가 아니라 `undefined`가 출력된다. **변수 선언이 런타임 이전 단계에서 먼저 실행되기 때문이다.**

`런타임` : 코드가 순차적으로 실행<br>
`호이스팅` : 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것<br>
`변수 호이스팅` : 변수 선언문이 코드의 선두에서 동작하는 JS의 고유한 특징

## 값의 할당
변수에 값을 할당 할 때 `할당 연산자 =`를 사용한다.<br>
- ex)<br>
![alt text](image-2.png)

`변수 선언`은 런타임 이전에 먼저 실행되지만, `값의 할당`은 런타임에 실행됨.

JS엔진은 변수의 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다. 따라서 변수에 `undefined`가 초기화되는 것은 변함이 없다. 즉, 변수에 값을 할당할 때 이전 값인 `undefined`의 메모리 공간을 지우고 새로운 값을 할당하는 것이 아니라, 새로운 공간을 확복하고 그곳에 할당 값`80`을 저장한다.

## 값의 재할당
: 이미 할당된 값이 있는 변수에 새로운 값을 다시 할당하는 것

var 키워드는 재할당이 가능함!

`변수`: 재할당 가능
`상수`: 변수에 저장된 값이 변경 불가능

 재할당 시 이전 메모리 공간을 지우고 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보해서 할당값을 지정한다~

 `가비지 콜렉터`: 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제 하는 기능으로, 메모리 누수를 방지한다.

 자바스크립트는 매니지드 언어로, 가비지 콜렉터를 내장하고 있음.

 `매니지드 언어`: 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하여 개발자의 직접적인 메모리 제어를 허용하지 않음! (자바스크립트 등등) <br>
 `언매니지드 언어`: 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 저수준 메모리 제어 기능을 제공한다. 개발자가 주도 가능함!(C언어 등등)

## 식별자 네이밍 규칙
- 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있음.
- 숫자로 시작하는 것은 허용하지 않음.
- 예약어는 식별자로 사용할 수 없음.

💡문제
1. 변수 선언과 값의 할당의 실행 시점에 대해 설명해보세요.
2. 가비지 콜렉터에 대해 설명해보세요.
3. 매니지드 언어와 언매니지드 언어에 대해 설명해보세요.
