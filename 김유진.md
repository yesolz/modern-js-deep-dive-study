# 23. 실행 컨텍스트
자바스크립트의 동작 원리를 담고 있는 핵심 개념으로, 실행 컨텍스트를 통해 자바스크립트에 대해 이해할 수 있는 것들은 아래와 같다 : 

- 스코프 기반으로 식별자와 식별자에 바인딩된 값을 관리하는 방식
- 호이스팅이 발생하는 이유
- 클로저의 동작 방식
- 태스크 큐와 함께 동작하는 이벤트 핸들러
- 비동기 처리의 동작 방식

## 1. 소스코드의 타입
소스코드는 4가지로 구분한다.

### 1) 전역 코드
: 전역에 존재하는 소스코드로, 함수, 클래스 등의 내부 코드는 포함❌
- 최상위 스코프인 전역 스코프 생성
- var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수 + 전역 객체
- 전역 코드 평가 시 전역 실행 컨텍스트 생성

```javascript
let globalVar = 10; // 전역 코드에서 선언된 변수
console.log(globalVar); // 전역 코드
```
### 2) 함수 코드
: 함수 내부에 존재하는 소스코드로, 중첩 함수, 클래스 등의 내부 코드 포함 ❌
- 지역 스코프 생성하고 지역 변수, 매개변수, arguments 객체를 관리
- 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결<br>
 --> 함수 코드 평가 시 함수 실행 컨텍스트 생성

```javascript
function greet() {
  console.log('Hello!'); // 함수 코드
}
greet(); // 함수 호출
```

### 3) eval 코드
: 빌트인 전역 함수인 eval 함수의 인수로 전달되어 실행되는 소스코드
- strict mode에서 자신만의 독자적인 스코프 생성<br>
--> eval 코드 평가 시 eval 실행 컨텍스트 생성
```javascript
eval('let x = 5; console.log(x);'); // eval 코드
```
실행 중에 새로운 스코프를 만들지 않고 현재 실행 중인 스코프에서 평가 됨(권장 x).

### 4) 모듈 코드
: 모듈 내부에 존재하는 소스코드로, 모듈 내부의 함수, 클래스 등의 내부 코드 포함❌
- 모듈별로 독립적인 모듈 스코프 생성<br>
--> 모듈 코드 평가 시 모듈 실행 컨텍스트 생성
- 파일 단위로 분리가 되어 있으면, 각 모듈이 자체 스코프를 가짐
- `import`와 `export`를 통해 모듈 간의 코드 공유 가능
- `this`가 `undefined`로 바인딩 되고, 전역 객체를 가리키지 않음

```javascript
// module1.js
export const name = 'Alice';

// module2.js
import { name } from './module1.js';
console.log(name); // 'Alice' 출력 (모듈 코드)
```
## 2. 소스코드의 평가와 실행
실행에 앞서 평과가정을 거치고 코드 실행을 위한 준비를 한다:

- `소스코드의 평가`
    - 실행 컨텍스트 생성
    - 변수, 함수 등의 선언문 먼저 실행 후 변수나 함수 식별자를 키로 스코프(렉시컬 환경의 환경 레코드)에 등록
- `소스코드의 실행`
   - 평가 후 선언문 제외한 소스코드가 순차적으로 실행
    - 스코프에서 검색해서 소스코드 실행에 필요한 정보를 취득
    - 변경 등 소스코드의 실행 결과는 스코프에 재등록
## 3. 실행 컨텍스트의 역할
### 1) 전역 코드 평가
- 소스코드 평가 과정에서는 선언문만 먼저 실행
- 결과로 생성된 전역 변수 및 함수는 전역 스코프(실행 컨텍스트가 관리하는)에 등록
- 이때 var 키워드로 선언된 전역 변수와 전역 함수는 전역 객체의 프로퍼티와 메서드가 됨

### 2) 전역 코드 실행
- 런타임 시작되며 전역 코드가 순차적으로 실행
- 전역 변수에 값 할당 후 함수 호출됨
- 함수 호출 후 순차적 진행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서 변경 후 함수 내부로 진입

### 3) 함수 코드 평가
- 함수 코드 평과 과정을 통해 실행 준비를 함
- 매개변수와 지역변수 선언문이 먼저 실행됨
- 이후 생성된 지역 변수가 지역 스코프에 등록 됨
함수 내부에서 지역 변수처럼 사용 가능한 arguments 객체가 생성되어 지역 스코프에 등록되고, **this 바인딩이 결정됨**

### 4) 함수 코드 실행
- 함수 코드가 순차적으로 실행되어 매개변수와 지역 변수에 값이 할당되고 `console.log`메서드가 호출 됨
    - 1. 식별자인 console을 스코프 체인 통해 검색
    - 2. log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색
    - 3. console.log 메서드에 인수로 전달된 표현식 평가
    - 4. 실행 종료 후 함수 코드 실행 과정이 종료되고, 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속함

코드 실행을 위해 스코프 구분과 식별자 바인딩 값이 관리되어야 한다.

그리고, 중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색되어야 한다.

또한, 함수 호출 종료 시, 호출 이전으로 돌아가기 위해서 현재 코드와 이전 코드를 구분 관리해야 한다.

--> 이 모든 것 제공하는 것이 실행 컨텍스트이다!

죽, 실행 컨텍스트는 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘이고, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.

>`식별자`와 `스코프`는 실행 컨텍스트의 **렉시컬 환경**으로 관리하고, `코드 실행 순서`는 **실행 컨텍스트 스택**으로 관리한다.


## 4. 실행 컨텍스트 스텍 
JS엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성한다. 그리고 함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성한다.

이때 생성된 실행 컨텍스트는 스택 자료구조로 관리한다.

### 실행 컨텍스트 스택의 동작 과정:
`전역 코드 실행`: 프로그램이 시작되면 전역 실행 컨텍스트가 생성되고 스택에 쌓임.<br>
`함수 호출 시 함수 실행 컨텍스트 생성`: 함수가 호출되면 해당 함수의 실행 컨텍스트가 새롭게 생성되어 스택에 쌓임.<br>
`함수 실행 완료 후 스택에서 제거`: 함수 실행이 끝나면 해당 함수의 실행 컨텍스트가 스택에서 제거됨.<br>
`콜 스택이 비어 있을 때 이벤트 루프 동작`: 비동기 코드의 실행은 콜 스택이 완전히 비워진 후 이벤트 루프에 의해 처리됨.

- 실행 컨텍스트는 자바스크립트 코드 실행 환경을 나타내며, 전역 코드, 함수 코드 등에서 각각 생성
- 실행 컨텍스트 스택은 실행 컨텍스트가 쌓이고 제거되는 구조로, 자바스크립트의 동기 코드 실행 흐름을 관리
- 비동기 코드의 실행은 콜 스택이 비워진 후 이벤트 루프를 통해 처리됩

## 5. 렉시컬 환경
: 식별자와 바인딩 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트이다.

렉시컬 환경은 코드의 실행 순서를 관리하는 실행 컨텍스트 스택과 달리 `스코프`와 `식별자`를 관리한다.

`객체 형태의 스코프`를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.

### 실행 컨텍스트의 구성
- LexicalEnvironment 컴포넌트
- variableEnvironment 컴포넌트

두 컴포넌트는 초기에 하나의 렉시컬 환경을 참조하지만, 이후 몇 가지 상황에 따라 VariableEnvironment 컴포넌트를 위한 새로운 렉시컬 환경이 생성되어 두 환경의 내용이 달라지기도 한다.

### 렉시컬 환경의 두 컴포넌트 구성
- ` 환경 레코드`:<br>
스코프에 포함된 식별자 등록, 바인딩 값 관리하는 저장소
- `외부 렉시컬 환경에 대한 참조`:<br> 
참조는 상위 스코프를 가리키고, 외부 렉시컬 환경에 대한 참조를 통해 단방향 링크드 리스트인 스코프 체인을 구현
## 6. 실행 컨텍스트의 생성과 식별자 검색 과정

## 7. 실행 컨텍스트와 블록 레벨 스코프
