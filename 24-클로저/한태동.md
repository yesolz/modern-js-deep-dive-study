# 22장. 클로저

날짜: 2024년 10월 8일

### 클로저(Closure) 요약

### 1. **정의**

클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합으로, 함수가 생성될 때 함수는 자신이 정의된 환경(스코프)과 함께 저장된다. 이를 통해 함수 내부에서 외부 스코프의 변수에 접근할 수 있게 된다.

### 2. **동작 원리**

- \*렉시컬 스코프(Lexical Scope)\*\*는 자바스크립트가 함수가 정의된 위치에 따라 스코프를 결정한다는 것을 의미한다. 즉, 함수가 호출되는 위치와 관계없이, 함수가 정의된 환경에 의해 변수 접근이 결정된다.
- 함수 객체는 자신의 내부 슬롯 `[[Environment]]`에 자신이 정의된 환경을 저장하여 외부 렉시컬 환경에 접근할 수 있게 한다.

### 3. **클로저의 특징**

- 클로저는 중첩 함수가 상위 스코프의 변수를 참조하고, 외부 함수보다 더 오래 유지될 때 발생한다. 이 경우, 외부 함수가 종료된 후에도 중첩 함수가 상위 스코프의 변수에 접근할 수 있다.
- 모든 자바스크립트 함수는 상위 스코프를 기억하기 때문에 이론적으로 클로저가 될 수 있지만, 상위 스코프의 변수를 참조하지 않으면 최적화되어 클로저로 동작하지 않을 수 있다.

### 4. **클로저의 활용 예시**

- **상태 유지**: 클로저는 외부에서 직접 접근할 수 없는 상태를 유지할 때 사용된다. 예를 들어, 특정 함수 안에서만 접근할 수 있는 변수를 만들고, 그 변수의 값을 조작하는 메서드를 제공하여 상태를 안전하게 관리할 수 있다.

  ```jsx
  const counter = (function () {
    let num = 0;
    return {
      increase() {
        return ++num;
      },
      decrease() {
        return num > 0 ? --num : 0;
      },
    };
  })();
  ```

- **정보 은닉**: 자바스크립트는 접근 제한자를 제공하지 않기 때문에 클로저를 이용하여 객체 내부의 상태를 감추고, 외부에서 직접 접근하지 못하도록 만드는 정보 은닉 기법을 사용할 수 있다.

### 5. **자주 발생하는 실수와 주의점**

- 전통적인 `var` 키워드를 사용한 for문 내에서 클로저를 사용할 때, 모든 함수가 마지막 값을 참조하는 문제가 발생할 수 있다. 이를 해결하기 위해 `let` 키워드를 사용하거나, 즉시 실행 함수(IIFE)를 사용할 수 있다.
- 다음 코드는 클로저를 사용할 때 발생할 수 있는 자주 실수를 보여준다:

```jsx
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  }; // ⓐ
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]()); // ⓑ
}
```

- ⓐ에서, 함수가 `funcs` 배열의 요소로 추가된다.
- ⓑ에서, `funcs` 배열의 요소로 추가된 함수를 순차적으로 호출할 때 `0, 1, 2`를 반환할 것으로 예상할 수 있지만, 실제로는 모두 `3`을 반환한다.

이 문제는 `for` 루프에서 `var` 키워드로 선언된 `i` 변수가 **블록 레벨 스코프**가 아닌 **함수 레벨 스코프**를 가지기 때문에 발생한다. 즉, `i`는 전역 변수로 취급되며, 루프가 완료된 후 값이 `3`으로 남아있게 된다. 따라서 `funcs` 배열에 저장된 함수들은 전부 전역 변수 `i`를 참조하게 되어 `3`을 반환하게 된다.

### 해결 방법 1: 즉시 실행 함수(IIFE)를 사용한 해결

위 문제를 해결하기 위해 **즉시 실행 함수(IIFE, Immediately Invoked Function Expression)**를 사용할 수 있다. 이를 통해 각 함수가 `i`의 값을 고유하게 유지할 수 있다.

```jsx
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = (function (id) {
    // ⓐ
    return function () {
      return id;
    };
  })(i);
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]()); // 0, 1, 2
}
```

- 즉시 실행 함수는 현재 `i` 값을 인수로 받아 `id`에 저장하고, 이 `id`를 참조하는 중첩 함수를 반환한다.
- 반환된 중첩 함수는 `id`를 참조하는 클로저가 되어, 함수가 호출될 때마다 각기 다른 `id` 값을 유지한다.

### 해결 방법 2: `let` 키워드 사용

ES6에서는 `let` 키워드를 사용하여 블록 레벨 스코프를 제공함으로써 더욱 간단하게 문제를 해결할 수 있다.

```jsx
const funcs = [];

for (let i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}

for (let i = 0; i < funcs.length; i++) {
  console.log(funcs[i]()); // 0, 1, 2
}
```

- `let` 키워드는 각 반복마다 새로운 렉시컬 환경을 생성하고, `i`는 그 환경에 종속되므로, 각각의 함수가 올바른 `i` 값을 참조하게 된다.

### 해결 방법 3: 고차 함수 사용

고차 함수(higher-order function)를 사용하여 반복문을 제거하고 클로저를 보다 간결하게 만들 수도 있다.

```jsx
// 요소가 3개인 배열을 생성하고 배열의 인덱스를 반환하는 함수를 요소로 추가한다.
// 배열의 요소로 추가된 함수들은 모두 클로저다.
const funcs = Array.from(new Array(3), (_, i) => () => i); // (3) [ƒ, ƒ, ƒ]

// 배열의 요소로 추가된 함수 들을 순차적으로 호출한다.
funcs.forEach((f) => console.log(f())); // 0, 1, 2
```

- `Array.from` 메서드를 사용하여 배열을 생성하고, 각 요소에 인덱스를 반환하는 함수를 할당한다.
- 이 방식은 변수 선언과 반복문 사용을 줄여 코드의 가독성을 높이고, 클로저를 더 간결하게 사용할 수 있게 한다.
