# 07장 연산자

`연산자` : 하나 이상의 **표현식(expression)** 을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 연산의 대상이 되는 것을 `피연산자 operand` 라 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야하며, 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다 → **피연산자는 “값”이라는 명사의 역할이면 연산자는 “피연산자를 연산하여 새로운 값을 만든다”라는 동사의 역할.**

## 07-1 산술 연산자

`산술 연산자 arithmetic operator` 는 피연산자를 수학적 계산을 수행해 새로운 숫자 값을 만듬. 산술 연산이 불가능할 경우에는 **NaN 을 반환.** 산술 연산자는 피연산자의 개수에 따라 **이항 산술 연산자와 단항 산술 연산자**로 구분할 수 있다.

## 07-1-1 이항 산술 연산자

`이항 산술 연산자 Binary Arithmetic Operators` : 2개의 피연산자를 산술 연산하여 숫자 값을 만듬. 모든 이항 산술 연산자는 피연산자의 값을 변경하지 아니하고, 산술 연산을 통해 언제나 새로운 값을 만든다. 대표적인 예로는 덧셈 (+) ,뺄셈 (-) , 곱셈 (\*), 나눗셈 (/), 나머지 (%)가 있다.

```jsx
5 + 2; // 7
5 - 2; // 3
5 * 2; // 10
5 / 2; // 2.5
5 % 2; // 1
```

→ 모든 이항 산술 연산을 통해 연산자의 값은 변동하지 않고 새로운 값만이 생성되었다.

## 07-1-2 단항 산술 연산자

`단항 산술 연산자 Unary Arithmetic Operators` : 1개의 피연산자를 산술 연산하여 숫자 값을 만듬. 대표적인 예로는 증가 (++), 감소 (—), 어떠한 효과도 없는 (+), 양수를 음수로 그리고 음수를 양수로 반전한 값을 반환하는 (-)

중요한점은, 이항 산술 연산자와는 다르게 **증가(++), 감소(—) 연산자는 피연산자의 값을 변경하는 부수 효과(side effect)가 있다라는 점이다.**

```jsx
let x = 1;
x++; // x = x + 1
console.log(x); // 2

x--; // x = x - 1
console.log(x); // 1
```

→ 증가/감소 연산자는 위치에 따라 의미가 변하는데, 증가/감소 연산자가 피연산자 앞에 올 경우 `(전위 증가/감소 연산자 prefix increment/decrement operator)` 피연산자의 값을 먼저 증가/감소 시킨 후 다른 연산을 수행하고, 피연산자 뒤에 올 경우 `(후위 증가/감소 연산자 postfix increment/decrement operator)` 다른 연산을 먼저 수행하고, 피연산자의 값을 증가/감소시킨다.

```jsx
let x = 5,
  result;
console.log(x, result); // 5, undefined

// 선할당 후 증가

result = x++; // x의 현재값이 5이기때문에, 우선 result에 5라는 값이 할당되고,할당 연산이 끝난 후에 x의 값이 하나 증가
console.log(result, x); // 5, 6

// 선증가 후 할당

result = ++x; // x의 현재값인 6에 1을 "먼저" 더 한 뒤에, 해당 값을 result에 재할당
console.log(result, x); // 7, 7

// 선할당 후 감소

result = --x; // x의 현재값 7을 먼저 result에 할당 , 이후 감소연산
console.log(result, x); // 7, 6

// 선감소 후 할당

result = --x; // x의 현재값 6에서 1을 "먼저" 빼고, 이 값을 result에 할당
console.log(result, x); // 5, 5
```

숫자 타입이 아닌 피연산자에 **+ 단항 연산자** 를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자 자체를 변경하는 것은 아니다(부수효과 x)

```jsx
let x = "1"; //string 타입

console.log(+x); // 문자열이었던 x를 "숫자 number" 형태 1로 반환
console.log(x); // "1" , 즉 부수효과는 없음

x = true;

console.log(+x); // 불리언 값을 숫자로 반환한다(true = 1, false = 0)
console.log(x); // true

x = false;

console.log(+x); // 0
console.log(x); // false

x = "Hello";
console.log(+x); // NaN -> 숫자형태의 문자열은 숫자로 변환이가능하나
// 알파벳이나 글자형태의 문자열은 숫자로 변환이 불가하기에 NaN 반환
console.log(x); // "Hello"

// - 단항 연산자도 비슷하나, 똑같이 부수효과는 없고 부호를 반전한 값을 반환

-(-10); // 10;
-"10" - // -10
  true - // -1
  false - // 0
  "Hello"; // NaN
```

## 07-1-3 문자열 연결 연산자

또한 `+` 연산자는 피연산자 중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작한다 → 이외에는 산술 연산자로서 동작함.

```jsx
"1" + 2; // 12
1 + "2"; // 12

// true는 1로, false는 0, null도 0으로 타입변환

1 + true; // 2
1 + false; // 1
1 +
  null + // 1
  // undefined는 숫자로 타입 변환되지 않는다
  undefined; // NaN
1 + undefined; // NaN
```

→ 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도함(ex. `1 + true` ). 이를 `암묵적 타입 변환 implicit coercion` 또는 `타입 강제 변환 type coercion` 이라한다.

## 07-2 할당 연산자

`할당 연산자 assignment operator` : 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 이로인해 변수의 값이 변하는 부수효과가 있다. 대표적으로는 =, +=, -=, \*=, /=, %= 가 있다.

표현식은 값으로 평가될 수 있는 문이고, 문에는 표현식인 문과 아닌 문이 있는데, 할당문은 표현식인가?

```jsx
let x;

console.log((x = 10)); // 10 , 따라서 할당문은 표현식인 문이다.
```

**_할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다_**

→ 위 예제에서 할당문 x = 10은 x에 할당된 숫자값 10으로 평가된다.

## 07-3 비교 연산자

`비교 연산자 comparison operator` : 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다. 주로 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.

## 07-3-1 동등/일치 비교 연산자

`동등 비교 연산자 loose equality operator` 와 `일치 비교 연산자 strict equality operator` 는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환. 하지만 **비교하는 엄격성의 정도가 다르다.**

<aside>

== (동등 비교) : x와 y의 값이 같음.

=== (일치 비교) : x와 y의 값과 타입이 같음

!= (부동등 비교) : x와 y의 값이 다름

!== (불일치 비교) : x와 y의 값과 타입이 다름

</aside>

- 동등 비교(==) 연산자는 먼저 암묵적 타입 변환을 통해 좌항과 우항의 피연산자를 타입 변환한 후 같은 값인지 비교한다.

```jsx
// 동등 비교

5 == 5; // true

// 숫자 == 문자열이지만 암묵적 타입 변환을 통해 타입을 먼저 일치시킨 후 비교

5 == "5"; // true
```

→ 동등 비교 연산자는 편리하지만, 결과를 예측하기 어려운 경우도 많이 발생한다. 따라서 사용하지 않는 편이 좋다.

```jsx
// 일치 비교

5 === 5; // true

// 암묵적 타입 변환을 하지 않고 값을 비교하기때문에
// 값은 동일하나 데이터 타입이 달라 false를 반환한다.

5 === "5"; // false

// 참고로 NaN은 자신과 일치하지않는 유일한 값이다
// NaN임을 확인하기 위해 빌트인 함수인 Number.isNaN을 사용할 수 있다

NaN === NaN; // false
Number.isNaN(NaN); // true
Number.isNaN(100); // false
Number.isNaN(1 + undefined); // true, 즉 NaN이다

// 자바스크립트에서는 양의 0과 음의 0이 존재하는데, 이를 비교하면 true가 나온다

0 === -0; // true
0 == -0; // true

// 동등 비교 연산자와 , 일치 비교 연산자는 위 연산을 동일하다고 했지만
// ES6에서 도입된 Object.is 메서드를 이용하면 정확한 비교 결과를 반영한다

-0 === +0; //true
Object.is(-0, +0); // false

NaN == NaN; //false
Object.is(NaN, NaN); //true
```

→ 부동등 비교 연산자( != ) 와 불일치 비교 연산자( !== ) 는 각각 동등비교(==) 연산자와 일치비교(===) 연산자의 반대 개념인것만 알고 넘어가자.

## 07-3-2 대소 관계 비교 연산자

`>` , `<` , `>=` , `<=` 가 있고, 각각 크다, 작다, 크거나 같다, 작거나 같다를 의미한다.

## 07-4 삼항 조건 연산자

`삼항 조건 연산자 tenary operator` : 조건식의 평가 결과에 따라 반환할 값을 결장하며, 자바스크립트의 유일한 삼항 연산자이다. 부수효과는 없음.

<aside>

조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값

</aside>

```jsx
let x = 2;

// 2%2는 0이며, 0은 false로 암묵적 타입 변환된다.
let result = x % 2 ? "홀수" : "짝수";
console.log(result); // 짝수
```

→ 물음표 앞의 존재하는 조건식은 불리언 타입의 값으로 평가될 표현식이며, 만약 조건식의 평가 결과가 불리언값이 아니면 불리언 값으로 암묵적 타입 변환됨을 알 수 있다.

삼항 조건 연산자 표현식은 if…else 문과 유사하나, 중요한 차이가 있는데 → 삼항 조건 연산자 표현식은 값처럼 사용할 수 있으나, if…else문은 값처럼 사용할 수 없다라는 점이다. 즉 if…else문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다. (여기서는 쉽게, **_변수에 담아 사용할 수 없다_**)

## 07-5 논리 연산자

`논리 연산자 logical operator` : 우항과 좌항의 피연산자 (부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다. 대표적으로 **|| (논리합 OR) , && (논리곱 AND), ! (부정)**이 있으며 이들 역시 부수효과는 없다.

논리 부정(!) 연산자는 언제나 불리언 값을 반환하나 피연산자가 반드시 불리언 값일 필요는 없다. 피연산자가 불리언값이 아니면 불리언 타입으로 암묵적 타입 변환된다.

```jsx
!0; // true, 0은 false로 암묵적 타입 변환되고 이의 반대인 true를 반환한다
!"Hello"; // 빈문자열이 아닌 "Hello"는 true로 평가되며, 따라서 false가 반환된다.
```

### Truthy 와 Falsy 값

`Truthy 값` : 어떤 값이 true로 평가되는 값 → 모든 값이 기본적으로 truthy이며, 비어 있지 않은 문자열이나 숫자, 객체, 배열은 모두 true로 평가된다. 참고로 빈 배열 [] 과 빈 객체 {} 도 truthy 값임.

`Falsy 값` : 어떤 값이 false로 평가되는 특정 값. 대표적으로 false, 0, -0, 0n(Bigint 0), “”(빈 문자열), null, undefined, NaN 이 있다.

<aside>
<img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4b4ecc4-e510-4e13-b43b-e6ba2df364f5/0f7bc610-277e-4063-816e-cc42e4e1dc53/pugderpq.png" alt="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4b4ecc4-e510-4e13-b43b-e6ba2df364f5/0f7bc610-277e-4063-816e-cc42e4e1dc53/pugderpq.png" width="40px" />

왜 다음의 값은 “Dog”가 나오는지 설명해주세요

“Cat” && “Dog”; // “Dog”

</aside>

> **정답** : 논리합( || ), 논리곱 ( && ) 연산자 표현식의 평가결과는 불리언값이 아닐수도있다. 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 한쪽으로 평가되는데,
> 정확하게 말하면 위 && 연산자의 경우 왼쪽 피연산자가 falsy 인 경우 그 값을 반환하며, 반대로 왼쪽이 truthy인 경우 오른쪽 피연산자를 평가하여 그 값을 반환한다.

”Cat” 은 truthy 값이므로, 오른쪽 피연산자인 “Dog” 를 평가하여 값을 반환하기때문에, 마지막값인 “Dog”가 반환된다.

만약 `0 && "Dog"` 가 있으면 0은 falsy값이기 때문에 왼쪽값인 0을 반환한다.

논리합(||) 연산자의 경우 왼쪽이 truthy일 경우 그 값을 반환하며, 왼쪽이 falsy일 경우 오른쪽 피연산자를 평가하여 그 값을 반환한다.

”cat” || “dog” → “cat”이 truthy이기 때문에, “cat”을 반환한다.

0 || “dog” → 0이 falsy이기 때문에 “dog”를 반환한다.

이렇게 논리 연산자(&&, ||)가 두번째 피연산자를 평가하기전에 첫번째 피연산자만으로 결과를 결정하는 방식을 `단축 평가` 라하며, 이 방식은 조건식의 평가를 최적화하여 불필요한 계산을 방지할 수 있다. 즉, 단축평가의 장점은 성능 최적화 및 코드를 간결하고 효율적으로 만들어 주는 중요한 기능을 한다.

>

## 07-6 쉼표 연산자

쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

```jsx
let x, y, z;

(x = 1), (y = 2), (z = 3); // 3

let a = (1, 2, 3);
console.log(a); // 3
```

## 07-7 그룹 연산자

소괄호로 피연산자를 감싸는 것. 이를 통해 연산자의 우선 순위를 조정할 수 있으며, 그룹 연산자는 연산자 우선 순위가 가장 높다!

## 07-8 typeof 연산자

피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자는 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 7가지 중 하나를 반환함. **_“null”은 반환하지 않는다._**

```jsx
let n = null;
console.log(typeof n); // object
console.log(typeof n === null); // false
console.log(n === null); // true
```

typeof 연산자로 null 값을 연산하면 위와같이 `object` 를 반환하는데, 이것은 자바스크립트의 유명한 버그이다. 값이 null 타입인지 확인할때는 typeof 를 사용하지말고 일치연산자(===)를 사용하자! 추가로, 선언하지 않은 식별자를 typeof 연산자로 연산시 ReferenceError 대신 undefined를 반환한다…

```jsx
let greet = "hello";
console.log(typeof great); //undefined
```

## 07-9 지수연산자

```jsx
2 ** 2; // 2의 2제곱, 4
2 ** 0; // 2의 0제곱, 1
2 ** -2; // 음수 지수는 분수로 변환 -> 2의 -2제곱, 1/4 (0.25)

// ES7에서 지수연산자가 도입되기전에는 Math.pow 메서드를 사용
Math.pow(2,2); // 4
Math.pow(2,0); // 1
Math.pow(2,-2); // 0.25

//음수를 밑으로 사용하려면 괄호로 묶어야한다

-5 ** 2 // SyntaxError
(-5) ** 2 // 25

//지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다

2 * 5 ** 2 // 5의 2제곱을 먼저한다음(25) 2를곱한다, 50
```

## 07-10 그 외의 연산자

`옵셔널 체이닝 연산자 ?.` , `null 병합 연산자 ??` , `프로퍼티 삭제 delete` , `생성자 함수를 호출할 때 사용하여 인스턴스를 생성하는 new` , `좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별하는 instanceof` , `프로퍼티 존재 확인하는 in` 이 친구들은 추후에 공부하는걸로🥲

## 07-11 연산자의 부수효과

대부분의 연산자는 다른 코드에 영향을 주지 않고 새로운 값만을 생성하지만(부수효과 X) , 할당 연산자(=), 증가/감소 연산자(++/—), delete 연산자는 부수효과를 갖는다.

```jsx
let obj = { a: 1 };

delete obj.a;
console.log(obj); // {}
```

→ `delete 연산자` 는 객체의 프로퍼티를 삭제하는 부수 효과가 있으며, 객체의 내용이 변경되기때문에 다른 코드에 영향을 준다.

## 07-12 연산자 우선순위

## 07-13 연산자 결합순서
