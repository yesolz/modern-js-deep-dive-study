# 11. 원시 값과 객체의 비교

원시 값과 객체 타입은 근본적으로 다르다. 크게 세 가지 측면.

- 원시 값은 immutable, 객체는 mutable value
- 원시 값을 변수에 할당하면 확보된 메모리 공간에는 실제 값이, 객체를 할당하면 참조 값이 저장
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달, 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사 되어 전달.

## 11.1 원시 값

- 변경 불가능한 값 : 불변성(immutability)
- 원시 값을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다. 이는 데이터의 신뢰성을 보장한다.

- C언어와 달리, 자바스크립는 원시 타입인 문자열을 제공함.
- 문자열이 생성된 이후에는 변경할 수 없음.

> 유사 배열 객체(array-like object)
>
> 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체.
> 문자열은 유사 배열 객체다. 원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환된다. (21.3절)

- 값에 의한 전달

```javascript
var score = 80;
var copy = score;
```

copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이므로, 어느 한쪽의 값이 변경되어도 서로의 값에 영향을 주지 않는다.

> '값에 의한 전달'은 자바스크립트 용어가 아니므로 오해가 있을 수 있다. 정확히는 변수에는 값이 아닌 메모리 주소가 전달되기 때문. 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

## 11.2 객체

객체는 프로퍼티 개수가 정해져 있지 않고, 동적으로 추가되고 삭제될 수 있으며, 프로퍼티 값에도 제약이 없다. 이러한 객체를 생성하고 관리하는 방식은 복잡하며 비용이 많이 들기 때문에 객체는 원시 값과 같은 방식으로 관리할 수 없다.

> 자바스크립트 객체 관리 방식
>
> 해시 테이블보다 나은 방법. 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있다. 사용은 편리하지만 성능적으로는 객체의 생성과 프로퍼티 접근에 비용이 더 많이 든다.
> 따라서 V8 자바스크립트 엔진은 프로퍼티에 접근하기 위해 동적 탐색(dynamic lookup) 대신 히든 클래스(hidden class) 라는 방식을 사용하는데, 자바와 같이 고정된 객체 레이아웃(클래스)과 유사하게 동작한다.

- 객체(참조) 타입의 값은 **변경 가능한 값(mutable value)**
- 객체를 할당한 변수의 경우 "변수는 객체를 참조하고 있다 / 가리키고(point) 있다"
- 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.
- 객체를 원시 값 같이 관리한다면, deep copy의 비용이 많이 든다. 메모리의 효율과 성능을 위해 객체는 mutable하다.
- 구조적 단점: **여러 개의 식별자가 하나의 객체를 공유할 수 있다.** (참조에 의한 전달)

```javascript
var person = {
  name: "Choi",
};
// 얕은 복사(참조 값을 복사)
var copy = person;
```

> _**자바스크립트의 "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다. 메모리 공간에 저장되어 있는 값의 차이만 있을 뿐이다. 따라서 엄밀히 말하면 자바스크립트에서는 "값에 의한 전달"만이 존재한다.**_

> _🙋 질문: 자바스크립트에서 원시 값은 왜 불변성(immutability)을 가지나요?_

> _🙋 질문: 객체가 mutable한 이유는 무엇이며, 그로 인해 발생할 수 있는 문제점은 무엇인가요?_
