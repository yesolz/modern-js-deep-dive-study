# 12. 함수

<aside>
💡

**변수 선언과 함수 정의**

함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.

</aside>

<aside>
💡

**생성자 함수**

객체를 생성하는 함수를 말한다.

</aside>

## 12.1 함수란?

### 수학에서 함수와 프로그래밍 언어의 함수는 같은 개념

**입력**을 받아 **출력**을 내보내는 일련의 과정

- **매개변수** : 함수 내부로 입력을 전달받는 변수
- **인수** : 입력
- **반환값** : 출력

```jsx
// 함수 정의
function add(x,y) {
// add는 함수 이름, x,y는 매개변수

 return x + y;
 // x + y는 반환값
}

// 함수 호출
add(2, 5) ;
// 2, 5는 인수
```

- **함수 호출**
    - 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적 지시

## 12.2 함수를 사용하는 이유

### 코드의 재사용 측면에서 유용하다.

1. **유지보수의 편의성**
2. **코드의 신뢰성**

## 12.3 함수 리터럴

### 함수는 객체 타입의 값이다.

- **함수 이름**
    - 함수 이름은 식별자다. 네이밍 규칙 준수
    - 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.
    - 함수 이름은 생략할수 있다. (익명함수)

- **매개변수 목록**
    - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분
    - 인수가 순서대로 할당된다. 매개변수 목록은 순서에 의미가 있다.
    - 매개변수는 함수 몸체 내에서 변수와 동일 취급, 네이밍 규칙 준수

- **함수 몸체**
    - 함수 몸체는 호출에 의해 실행된다.

## 12.4 함수 정의

### 함수 선언문, 표현식, 생성자 함수, 화살표 함수 4가지 정의가 있다.

```jsx
// 함수 선언문
function add(x , y) {
	return x + y;
}

// 함수 표현식
var add = function (x , y) {
	return x + y;
}

// Function 생성자 함수
var add = new Function ('x', 'y', 'retrun x + y');

// 화살표 함수
var add = (x , y) => x + y;
```

### 함수 선언문

**함수 선언문은 함수 이름을 생략할 수 없다.**

**함수 선언문은 표현식이 아닌 문이다.**

그러므로 변수에 할당할 수 없다.

```jsx
var add = function add(x, y) {
	return x + y;
};

console.log(add(2,5));
```

변수에 할당되는 것처럼 보인다.

함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면

함수 리터럴과 형태가 동일하다.

(기명 함수의 경우 둘 중 하나로 해석될 가능성이 있다는 의미)

**함수 선언문**의 경우 함수 이름이 있는 함수 리터럴을 **단독**으로 사용

```jsx
// 함수 선언문
function add (x, y) {
	return x + y;
};
```

**함수 리터럴**의 경우 변수에 **할당**하거나 **피연산자**로 사용

```jsx
// 함수 리터럴
var add = function add(x, y) {
	return x + y;
};

console.log(add(2,5));
```

함수 이름은 함수 몸체 외부에서 사용할 수 없다.

함수 리터럴의 경우 식별자가 붙지 않으면 호출할수 없다.

```jsx
(function bar() {console.log('bar');});
bar(); // ReferenceError
```

bar은 함수 외부에서 사용할수 없다.

함수 선언문의 경우는 **암묵적으로 식별자**를 생성한다.

```jsx
function foo() { console.log('foo'); }
foo(); // foo

// 의사 코드로 표현
var foo = function foo() { console.log('foo'); }
```

결론적으로 함수 선언문을 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있다.

하지만 정확히 동일하게 동작하는 것은 아니다.

### 함수 표현식

**값의 성질을 갖는 객체를 일급 객체라 하고 함수는 일급 객체다.**

함수 객체를 변수에 할당할 수 있고 **함수 표현식**이라 한다.

함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.

### 함수 생성 시점과 함수 호이스팅

**함수 선언문은 선언문 이전 호출 가능, 표현식은 이전 호출 불가능**

**호이스팅 :** 선두로 끌어 올려진 것 처럼 동작하는 고유의 특징

### **변수 호이스팅, 함수 호이스팅 차이**

var 키워드로 선언된 변수는 undefined로 초기화,

함수 선언문을 통해 암묵적 생성된 식별자는 함수 객체로 초기화 된다.

- **함수 선언문**
    - 런타임 이전 객체 생성

- **함수 표현식**
    - 런타임에 평가된다.
    - 변수 호이스팅 발생
    
    ### 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하기에 표현식을 사용할 것을 권장
    

### Function 생성자 함수

### 클로저를 생성하지 않는 등, 함수 선언문이나 표현식으로 생성한 함수와 다르게 동작한다.

### 화살표 함수

### ⇒ 를 사용해 더 간략한 방법, 익명 함수로 정의한다.

```jsx
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

**내부 동작**도 간략화 되어있다.

this 바인딩 방식이 다르고, prototype 프로퍼티가 없고, arguments 객체를 생성하지 않는다.

## 12.5 함수 호출

### 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.

- 0개 이상의 인수를 쉼표로 구분해서 나열
- 호출되면 실행 흐름을 중단, 호출된 함수로 실행 흐름을 옮긴다.
- 매개 변수에 인수가 순서대로 할당, 몸체 문들이 실행

### 매개변수와 인수

**함수 실행을 위해 외부에서 함수 내부로 전달할 필요가 있는 경우 매개변수를 통해 인수를 전달한다.**

인수는 값으로 평가될 수 있는 표현식이어야 한다.

```jsx
function add(x, y) {
	return x + y;
}

// 함수 호출
// 인수 1과 2가 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행
var result = add(1, 2);

console.log(x, y); // ReferenceError
```

매개 변수는 함수 몸체 내부에서만 참조 가능하다.

인수가 부족한 경우 할당되지 않은 매개변수 값은 undefined다.

초과된 인수는 무시된다.

(암묵적 arguments 객체의 프로퍼티로 보관)

### 인수 확인

1. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
2. 자바스크립트는 동적 타입 언어다. 매개변수의 타입을 사전에 지정할 수 없다.

따라서 자바스크립트의 경우 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다.

### 매개변수의 최대 개수

### 최대 개수에 대해 명시적 제한하고 있지 않다.

이상적인 함수는 가급적 매개변수를 작게 만들어야 한다.

(3개를 넘지 않을 것을 권장)

만약 많은 매개변수가 필요하면

하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.

```jsx
function showUserInfo(user) {
  console.log(`Name: ${user.name}`);
  console.log(`Age: ${user.age}`);
  console.log(`Email: ${user.email}`);
}

// 객체를 인수로 전달
showUserInfo({
  name: 'David',
  age: 28,
  email: 'david@example.com'
});
```

부수 효과(함수 내부 변경시 외부 객체 변경)가 발생한다.

### 반환문

### return 키워드와 표현식(반환값)으로 실행 결과를 외부로 반환 할 수 있다.

```jsx
function add (x, y) {
	return x + y; // 반환문
	console.log('실행되지 않는다.');
}

var result = add(3, 5);
console.log(result); // 8
```

1. 반환문 이후 다른 문이 있으면 무시된다.
2. return 키워드 뒤에 오는 표현식을 평가해 반환한다.
    
    (명시적 지정을 하지 않으면 undefined가 반환)
    

## 12.6 참조에 의한 전달과 외부 상태의 변경

### 매개변수도 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따른다.

```jsx
function add (x, y) {
	x += 100;
	y.name = 'Lee';
}

var num = 100;
var person = { name : 'Kim" };

add(num, person);

// 원시 값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // {name: 'Lee'}
```

원시 값은 변경 불가능한 값이므로 직접 변경 불가

객체는 변경 가능한 값이므로 직접 변경이 가능하다.

원시 값은 원본을 변경하는 부수 효과가 발생하지 않고

객체는 원본의 변경이 일어나는 부수 효과가 발생한다.

## 12.7 다양한 함수의 형태

### 즉시 실행 함수

**정의와 동시에 호출되는 함수를 말한다.**

단 한번만 호출되고 다시 호출할 수 없다.

```jsx
(function () {
	var a = 3;
	var b = 5;
	return a * b;
}());

(function foo () {
	var a = 3;
	var b = 5;
	return a * b;
}());

foo(); // RefernceError
```

익명 함수를 사용하는 것이 일반적이다.

기명 즉시 함수의 경우 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자 이므로 다시 호출은 불가능하다.

즉시 실행 함수는 반드시 그룹 연산자() 로 감싸야 한다.

```jsx
// 함수 선언문의 형식이 맞지 않아서, 함수 선언문은 함수 이름을 생략할수 없다.
function () {} ();

// 세미콜론 자동 삽입 기능에 의해 중괄호 뒤에 ;이 암묵적 추가
// 선언문 위에 ()는 그룹 연산자로 해석, 피연산자가 없기에 에러
function foo() {} (); // => function foo() {}; ();
```

### 재귀 함수

함수가 자기를 호출하는 것을 **재귀 호출**, 재귀 호출을 수행하는 함수가 **재귀 함수**라 한다.

반복문 없이도 반복을 진행할수 있다.

```jsx
function countdown(n) {
	if (n < 0) return;
	console.log(n);
	countdown(n -1) ; // 재귀 호출
}

countdown(10)
```

함수 표현식의 경우 함수 이름은 함수 내부에서만 작동이 가능하고 함수를 가리키는 식별자로도 재귀호출이 가능하다.

```jsx
var add = function countdown(n) {
	if (n < 0) return;
	console.log(n);
	add(n -1) ; // 재귀 호출
}

countdown(10)
```

무한 재귀 호출이 진행되기에 **탈출 조건**을 반드시 만들어야 한다.

### 중첩 함수

함수 **내부**에 정의된 함수를 **중첩 함수, 내부 함수**라 한다. **중첩 함수를 포함**하는 함수는 **외부 함수**라 한다.

중첩 함수는 외부 함수 내부에서만 호출 가능하다.

```jsx
function outer() {
	var x = 1;

// 중첩 함수
	function inner() {
	var y = 2;
	// 외부 함수의 변수를 참조할 수 있다.
	console.log(x + y); // 3
	}
	
	inner();
}

outer();
```

if, for문의 코드 블록 내에서도 정의가 가능하나 **호이스팅**으로 인해 혼란이 올 수 있어 권장하지 않는다.

### 콜백함수

**콜백 함수** : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

**고차 함수** : 매개변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수

```jsx
function repeat(n, f) {
	for (var i = 0; i < n; i++) {
	f(i);
	}
}

var logAll = function (i) {
	console.log(i);
};

repeat(5, logAll); // 0 1 2 3 4

```

### 순수 함수와 비순수 함수

- **순수 함수**
    - 외부 상태에 의존하지도 않고 변경하지도 않는(부수 효과가 없는)
- **비순수 함수**
    - 외부 상태에 의존하거나 외부 상태를 변경하는(부수 효과가 있는)

```jsx
// 순수 함수

var count = 0;

function increase(n) {
	return ++n;
}

count = increase(count);
console.log(count); //1

// 비순수 함수

var count = 0;

function increase() {
	return ++count;
}

increase();
console.log(count); //1
```

외부상태에 의존하느냐 의존하지 않느냐의 차이고 순수 함수를 사용해 부수 효과를 최대한 억제하는게 좋다.
