# 05장 표현식과 문

## 05-1 값

`값` : **식(표현식 expression)이 평가(evaluation)되어 생성된 결과**

`평가` : 식을 해석해서 값을생성하거나 참조하는 것을 의미

모든 값은 데이터 타입을 가지며, 메모리에 2진수 (비트의 나열)로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있는데, 예를들어 메모리에 저장된 2진수 값이 `0100 0001` 이라면 숫자로 65지만, 문자로 해석하면 “A” 임. 

```jsx
var sum = 10 + 20;
```

→ sum 변수에 할당되는 것은 10+20이 아닌 10+20이 ***평가*** 된 결과인 숫자 값 30. 따라서 10+20은 할당 이전에 평가되어 값을 생성해야한다.

---

## 05-2 리터럴

`리터럴 literal` : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

![image](https://github.com/user-attachments/assets/55843a4d-1968-455b-9f70-f4f4fe9fc266)

위 “3” 이라는 숫자는 단순한 아라비아 숫자가 아니라 `숫자 리터럴` 이며 사람이 이해할 수 있는 아라비아 숫자인 3을 이용해 숫자 리터럴 3을 코드에 기술하면 자바스크립트 엔진은 이를 `평가` 하여 숫자 값 3을 생성한다. 리터럴은 사람이 이해할 수 있는 문자 또는 미리 약속된 기호(””, ‘’, [], {},//) 등으로 표기한 코드인데, 즉 리터럴은 **값을 생성하기 위해 미리 약속한 표기법**

![image](https://github.com/user-attachments/assets/2a54e4c9-e84d-4ab7-90de-72604fb31a7d)


---

## 05-3 표현식

`표현식 expression` : 값으로 평가될 수 있는 문(statement). 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조한다. 그렇기때문에 리터럴도 그자체로 표현식이다.

```jsx
var score = 100;
```

→ 100은 리터럴, 리터럴 100은 자바스크립트 엔진에 의해 평가되어 값을 생성하므로 리터럴 그 자체가 표현식

```jsx
var score = 50+50;
```

→ 50 + 50 은 리터럴과 연산자로 이뤄져 있음. 50+50은 평가되어 숫자값 100을 생성하기때문에 얘도 표현식

```jsx
score; // score 변수 참조 (100)
```

→ **변수 식별자를 참조한다 = 변수 값으로 평가된다**

식별자 참조는 값을 생성하는 것은 아니지만, 값으로 평가되기때문에 표현식, 

어렵게 생각할 것 없이 **값으로 평가될 수 있는 문은 모두 표현식이다**

### 동치?

표현식은 값으로 평가된다고 했는데, 표현식과 표현식이 평가된 값은 동등한 관계. 즉, `동치(equivalent)` 이다.

`1 +  2 = 3` 에서 1+2는 평가되어 값 3을 생성하므로 표현식 1+2와 값 3은 동치다. 표현식은 값처럼 사용할 수 있으며 이는 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있음을 의미

- 예를 들어, `산술연산자 (operator)` + 의 좌항과 우항에는 숫자값이 위치해야한다. 이때 숫자값으로 평가될 수 있는 표현식이라면 숫자값 대신 사용 가능.

```jsx
var x = 1 + 2;

// 식별자 표현식 x는 3으로 평가
x+3; // 6
```

x+3 은 표현식인데, + 연산자는 좌항과 우항의 값을 산술 연산하는 연산자이기때문에 좌항과 우항에는 숫자값이 위치해야한다. 이때 좌항 x는 식별자 표현식이며, x에는 이미 할당되어있는 숫자값3이 평가 되기때문에, 원래 숫자값이 위치해야할 자리에 표현식 x를 대신 사용할 수 있다.

---

## 05-4 문

`문 statement` : 프로그램을 구성하는 기본 단위이자 최소 실행단위. 명령문이라고도 한다. 문의 집합으로 이뤄진 것이 프로그램. 문을 작성하고 순서에 맞게 나열하는것이 프로그래밍. 문은 여러개의 토큰으로 구성되는데,

`토큰 token` : 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본요소

<aside>
<img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4b4ecc4-e510-4e13-b43b-e6ba2df364f5/bcb7ed66-e8d1-450e-9ff1-7b378a396e12/disco_pug.gif" alt="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4b4ecc4-e510-4e13-b43b-e6ba2df364f5/bcb7ed66-e8d1-450e-9ff1-7b378a396e12/disco_pug.gif" width="40px" />

![image](https://github.com/user-attachments/assets/a9ee7c5a-abc8-4dea-8bb0-a6118315d361)


</aside>

---

## 05-5 세미콜론과 세미콜론 자동 삽입기능

- 세미콜론은 문의 종료를 나타낸다. 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행하기때문에, 문을 끝낼때는 세미콜론을 붙여야한다.
- 단!! 0개 이상의 문을 중괄호로 묶은 코드블럭({…}) 뒤에는 세미콜론을 붙이지않음
    - Ex) if 문, for 문, 함수등의 코드 블록 뒤에는 세미콜론을 붙이지않는다
    - 왜냐하면 이러한 코드블록은 언제나 문의 종료를 의미하는 `자체 종결성` 을 갖기때문.

```jsx
let score = 85;

// if문 블록 : 마지막 중괄호 옆에 세미콜론 붙이지않는다
if (score > 80) {
  console.log("Passed!");
} else {
  console.log("Try again.");
}

// 함수도 본문이 {} 로 묶여있기 때문에 {} 블록 자체에는 세미콜론 붙이지 않는다
function greet(name) {
  console.log("Hello, " + name);
}

greet("Jinyong");
```

---

## 05-6 표현식인 문과 표현식이 아닌 문

```jsx
// 변수 선언문은 "값으로 평가" 될 수 없기때문에 표현식이 아님!
var x;

// 1, 2, 1+2, x = 1+2 는 모두 표현식
// x = 1+2 는 표현식이면서 완전한 문임
x = 1+2 
```

표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해보는 것

```jsx
//표현식이 아닌 문은 값처럼 사용 불가능
let y = let z; // SyntaxError: Unexpected token error
```

```jsx
//위에서도 말했듯이 변수 선언문은 표현식이 아님
let y;

//할당문은 이 자체가 표현식이지만 완전한 문이기도함. 따라서 값처럼 사용가능
y = 100;
```
